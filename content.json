{"meta":{"title":"玩原神玩的","subtitle":"Genshin","description":"老师你喜欢玩原神吗，或者星铁","author":"Guoyangyang & Yangxingyu & Dongxiaoyu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"GitHub-For-Unity","date":"2023-06-17T13:14:25.899Z","updated":"2023-06-17T13:14:25.899Z","comments":true,"path":"2023/06/17/GitHub-For-Unity/","link":"","permalink":"http://example.com/2023/06/17/GitHub-For-Unity/","excerpt":"","text":"# GitHub-For-Unity 网上找到了一个针对 Unity 的 GitHub 工具，折腾了一上午，终于 push 成功了。感觉还是挺好用的，稍稍介绍一下。 这是项目地址：https://github.com/github-for-unity/Unity # 安装 这个包有两种安装方式，一种是自己下载，手动导入工程中，另一种是通过 Asset Store 商店下载安装 # 先说一下第一种 可以从官网或者 GitHub 下载最新版工程文件 官网：https://unity.github.com/ GitHub： https://github.com/github-for-unity/Unity/releases 可以下载最新版安装包，得到一个 unitypackage 文件，然后直接导入自己的工程就行。 # 第二种 去 Asset Store 直接搜 github-for-unity 添加到我的资源 # 导入与初始化 将包导入 unity 工程后，可以在 windows 菜单中访问它 先进行初始化 然后打开 GitHub 的菜单，右上角有 sign in 选项 登录你自己的 GitHub 账号（这一步有问题的话可以关闭工程重新打开） 然后我们去 GitHub 网站建一个库，方便我们 push 给仓库起个名字，添加描述。 我们需要一个空仓库，所以这一步不添加 readme 文件，不添加.gitignore 不选择 license (就是说全部保持默认即可) 复制一下这个代码 粘贴到这里，然后点 save responsibility。这里就是我们一会要 push 的仓库地址 提交 changes，添加描述 可以在历史记录看到更改 然后我们就可以 push 了 push 成功啦，我们现在可以在刚刚创建的仓库里面看到更改了 # 一些问题 遇到问题最多的是 push 的时候 # 报错 Failed to connect to github.com port 443: Timed out 这个可能时网络或者代理的错误，我也试了很多办法。 # 1. 关闭项目代理 进入项目的本地仓库目录下，右键 Git Bash Here 进入控制台，分别执行以下两个命令： 12git config --global --unset http.proxygit config --global --unset https.proxy # 2. 修改 hosts 文件 进入 C:\\Windows\\System32\\drivers\\etc 目录下 打开 host 文件，我这里选择记事本打开 查找一下 GitHub 网站的 IP 地址，填进去 用这个网站查：https://ipaddress.com/website/github.com 复制一下 ip 地址，填到 # ::1 localhost 下面一行 这是网上的办法，如果不能解决的话，可以换个加速器，或者重启试试 我这里用 steam++ 解决了这个问题。 # git SSL certificate problem: unable to get local issuer certificate 这是由于当你通过 HTTPS 访问 Git 远程仓库的时候，如果服务器上的 SSL 证书未经过第三方机构认证，git 就会报错。原因是因为未知的没有签署过的证书意味着可能存在很大的风险 进入当前仓库的目录，打开 git bash here，输入命令 123456git config http.sslverify false//这是对于当前仓库而言的 git config --global http.sslverify false//这个是针对当前系统用户git config --system http.sslverify false//这个是对于全局系统所有用户 这些便是我在使用 github-for-unity 的时候遇到的一些问题，总的来说，这是一个很方便的工具，值得试试！ 如果你在使用这个插件的过程中遇到了其他问题，可以与我联系 邮箱:guo23188@qq.com 或者去 bilibili 私信我：https://space.bilibili.com/487294924?spm_id_from=333.1007.0.0 感谢你能够看到这里，我们下次再见啦！","categories":[],"tags":[]},{"title":"","slug":"Unity的gitignore","date":"2023-06-17T13:14:04.679Z","updated":"2023-06-17T13:14:04.680Z","comments":true,"path":"2023/06/17/Unity的gitignore/","link":"","permalink":"http://example.com/2023/06/17/Unity%E7%9A%84gitignore/","excerpt":"","text":"# Unity 的 gitignore 输入 1touch .gitignore 建立一个 gitignore 文件 然后粘贴 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# This .gitignore file should be placed at the root of your Unity project directory## Get latest from https://github.com/github/gitignore/blob/main/Unity.gitignore#/[Ll]ibrary//[Tt]emp//[Oo]bj//[Bb]uild//[Bb]uilds//[Ll]ogs//[Uu]ser[Ss]ettings/# MemoryCaptures can get excessive in size.# They also could contain extremely sensitive data/[Mm]emoryCaptures/# Recordings can get excessive in size/[Rr]ecordings/# Uncomment this line if you wish to ignore the asset store tools plugin# /[Aa]ssets/AssetStoreTools*# Autogenerated Jetbrains Rider plugin/[Aa]ssets/Plugins/Editor/JetBrains*# Visual Studio cache directory.vs/# Gradle cache directory.gradle/# Autogenerated VS/MD/Consulo solution and project filesExportedObj/.consulo/*.csproj*.unityproj*.sln*.suo*.tmp*.user*.userprefs*.pidb*.booproj*.svd*.pdb*.mdb*.opendb*.VC.db# Unity3D generated meta files*.pidb.meta*.pdb.meta*.mdb.meta# Unity3D generated file on crash reportssysinfo.txt# Builds*.apk*.aab*.unitypackage*.app# Crashlytics generated filecrashlytics-build.properties# Packed Addressables/[Aa]ssets/[Aa]ddressable[Aa]ssets[Dd]ata/*/*.bin*# Temporary auto-generated Android Assets/[Aa]ssets/[Ss]treamingAssets/aa.meta/[Aa]ssets/[Ss]treamingAssets/aa/* 网址：https://github.com/github/gitignore/blob/master/Unity.gitignore","categories":[],"tags":[]},{"title":"","slug":"Unity剧情编辑","date":"2023-06-17T13:14:04.562Z","updated":"2023-06-17T13:14:04.563Z","comments":true,"path":"2023/06/17/Unity剧情编辑/","link":"","permalink":"http://example.com/2023/06/17/Unity%E5%89%A7%E6%83%85%E7%BC%96%E8%BE%91/","excerpt":"","text":"# Unity 剧情编辑 # Fungus 下载链接：https://github.com/snozbot/fungus # 使用方法 先创建一个 flowchart 选中节点之后，右边可以设置属性。 勾选这个，可以选择颜色。 用不同的颜色来区分不同的节点。 对话系统开始的时间 点加号，添加一个事件。 搜索 say。 输入说的内容。 创建一个说话的角色。 可以添加说话的图像。 在事件这里选说话的对象。 可以给标签添加效果。 创建 menu 事件让玩家选择。 记得选对应的目标节点。 没有 menu，想跳转节点的话，可以使用 Scene/Message Received 在上一个节点创建 send message 事件。 message 和刚才保持一至。 # 美化 可以创建自定义对话框。 # 动画 新建空对象，加上 Playable Director 组件。 创建几个 timeline。 把 timeline 拖过来。 选中人物模型，拖拽到 timeline 上。 可以添加动画片段。 不同的片段可以重合在一起，自动生成过渡效果。 可以添加变量控制动画。 然后在剧情控制这里设置变量。 给动画控制器加个脚本： 123456789101112131415161718192021222324252627using System.Collections;using System.Collections.Generic;using Fungus;using UnityEngine;using UnityEngine.Playables;using UnityEngine.Timeline;public class Controller : MonoBehaviour&#123; public PlayableDirector animationController; public TimelineAsset[] timelines; public string[] timelineNames; public Flowchart flowchart; void Update() &#123; for (int i = 0; i &lt; timelines.Length; i++) &#123; if (flowchart.GetBooleanVariable(timelineNames[i])) &#123; animationController.Play(timelines[i]); &#125; flowchart.SetBooleanVariable(timelineNames[i],false); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"CUDA","date":"2023-06-17T13:12:47.907Z","updated":"2023-06-17T13:12:47.908Z","comments":true,"path":"2023/06/17/CUDA/","link":"","permalink":"http://example.com/2023/06/17/CUDA/","excerpt":"","text":"# Benefit of GPU GPU 和 CPU 之间的能力差异是因为它们在设计时考虑了不同的目标。CPU 的设计目标是尽可能快地执行一系列被称为线程的操作，并且可以并行执行几十个这样的线程，而 GPU 的设计目标是并行执行数千个这样的操作 (摊销较慢的单线程性能以实现更大的吞吐量)。 GPU 专为高度并行计算而设计，因此更多的晶体管用于数据处理，而不是数据缓存和流控制。 # CUDA: 一种通用并行计算平台和编程模型 # 可伸缩编程模型 它的核心是三个关键的抽象 —— 线程组的层次结构、共享内存和障碍同步 —— 它们只是作为语言扩展的最小集合公开给程序员。 这些抽象提供了细粒度的数据并行性和线程并行性，嵌套在粗粒度的数据并行性和任务并行性之中。它们指导程序员将问题划分为可以由线程块独立并行解决的粗子问题，并将每个子问题划分为可以由块内所有线程并行合作解决的细子问题。 Automatic Scalability # Programming Model CUDA c 扩展了 c，允许程序员定义 c 函数，称为内核，当调用时，被 N 个不同的 CUDA 线程并行执行 N 次，而不是像普通的 c 函数一样只执行一次。 每个块的线程数量是有限制的，因为一个块的所有线程都驻留在同一个流多处理器内核上，并且必须共享该内核的有限内存资源。在当前的 gpu 上，一个线程块最多可以包含 1024 个线程。 但是，一个内核可以由多个形状相同的线程块执行，这样线程总数就等于每个块的线程数乘以块的数量。 每个块的线程数和每个网格的块数在 &lt;&lt;&lt;…&gt;&gt;&gt; 语法的类型可以是 int 或 dim3。可以像上面的示例那样指定二维块或网格。 网格中的每个块都可以通过内核中内置的 blockIdx 变量访问的一维、二维或三维唯一索引来标识。线程块的尺寸可以在内核中通过内置的 blockDim 变量访问。 12345678910111213141516∕∕ Kernel definition __global__ void MatAdd(float A[N][N], float B[N][N], float C[N][N])&#123; int i = blockIdx.x * blockDim.x + threadIdx.x; int j = blockIdx.y * blockDim.y + threadIdx.y; if (i &lt; N &amp;&amp; j &lt; N) C[i][j] = A[i][j] + B[i][j]; &#125; int main() &#123; ... ∕∕ Kernel invocation dim3 threadsPerBlock(16, 16); dim3 numBlocks(N ∕ threadsPerBlock.x, N ∕ threadsPerBlock.y); MatAdd&lt;&lt;&lt;numBlocks,threadsPerBlock&gt;&gt;&gt;(A,B,C);... &#125; 块中的线程可以通过共享内存共享数据，并通过同步它们的执行来协调内存访问。更准确地说，可以通过调用__syncthreads () 内在函数来指定内核中的同步点；__syncthreads () 充当了一个屏障，在允许任何线程继续之前，块中的所有线程都必须等待。共享内存给出了一个使用共享内存的示例。除了__syncthreads ()， Cooperative Groups API 还提供了一组丰富的线程同步原语。为了高效的合作，共享内存应该是靠近每个处理器核心的低延迟内存 (很像 L1 缓存)，而__syncthreads () 应该是轻量的 # Thread Block Clusters With the introduction of NVIDIA Compute Capability 9.0, CUDA 编程模型引入了一个可选的层次结构级别，称为线程块集群，由线程块组成。类似于线程块中的线程如何保证在流多处理器上共调度，集群中的线程块也保证在 GPU 中的 GPU 处理集群 (GPC) 上共调度。 与线程块类似，集群也被组织成一维、二维或三维，如图 5 所示。 # Memory Hierarchy CUDA 线程在执行过程中可以从多个内存空间访问数据，每个线程都有私有的本地内存。每个线程块都具有对该块的所有线程可见的共享内存，并且具有与该块相同的生命周期。线程块集群中的线程块可以在彼此的共享内存上执行读、写和原子操作。所有线程都可以访问相同的全局内存。 另外还有两个所有线程都可以访问的只读内存空间：常量和纹理内存空间。全局、常量和纹理内存空间针对不同的内存使用进行了优化 (参见设备内存访问)。纹理内存还为某些特定的数据格式提供了不同的寻址模式，以及数据过滤 (参见纹理和表面内存)。 全局内存、常量内存和纹理内存空间在同一应用程序的内核启动过程中是持久化的。 # Heterogeneous Programming CUDA 编程模型假设 CUDA 线程在物理上独立的设备上执行，该设备作为运行 c 程序的主机的协处理器。例如，当内核在 GPU 上执行，而 c 程序的其余部分在 CPU 上执行时，就是这种情况。 CUDA 编程模型还假定主机和设备都在 DRAM 中维护各自独立的内存空间，分别称为主机内存和设备内存。因此，程序通过调用 CUDA 运行时 (在编程接口中描述) 来管理内核可见的全局、常量和纹理内存空间。这包括设备内存分配和回收，以及主机和设备内存之间的数据传输。 统一内存提供托管内存，以桥接主机和设备内存空间。托管内存可以从系统中的所有 cpu 和 gpu 访问，作为具有公共地址空间的单个连贯内存映像。此功能支持设备内存的超额订阅，并且通过消除在主机和设备上显式镜像数据的需要，可以极大地简化移植应用程序的任务。 # Asynchronous SIMT Programming Model 在 CUDA 编程模型中，线程是在内存操作上进行计算的最低抽象级别。从基于 NVIDIA Ampere GPU 架构的设备开始，CUDA 编程模型通过异步编程模型为内存操作提供加速。 异步编程模型定义了与 CUDA 线程相关的异步操作的行为。异步编程模型定义了用于 CUDA 线程之间同步的异步 Barrier 行为。该模型还解释并定义了 cuda: memcpy_async 如何在 GPU 计算时从全局内存异步移动数据。 # Asynchronous Operations 异步操作被定义为由 CUDA 线程发起并像由另一个线程一样异步执行的操作。在一个结构良好的程序中，一个或多个 CuDA 线程与异步操作同步。发起异步操作的 CUDA 线程不需要在同步线程中。 这样的异步线程 (as-if 线程) 总是与发起异步操作的 CUDA 线程相关联。异步操作使用同步对象同步操作的完成。这样的同步对象可以由用户显式管理 (例如 cuda::memcpy_async)，也可以在库中隐式管理 (例如 cooperative_groups::memcpy_async)。 同步对象可以是 cuda:: barrier 或 cuda:: pipeline。这些对象在异步屏障和使用 cuda: pipeline 的异步数据拷贝中有详细的解释。这些同步对象可以用于不同的线程作用域。作用域定义了可以使用同步对象与异步操作同步的线程集。下表定义了 CUDA c++ 中可用的线程范围以及可以与每个线程同步的线程。 # Compute Capability # Programming Interface 它由 c 语言的最小扩展集和运行时库组成。核心语言扩展已经在编程模型中引入。它们允许程序员将内核定义为 c 函数，并在每次调用函数时使用一些新的语法来指定网格和块维度。所有扩展的完整描述可以在 c++ 语言扩展中找到。任何包含这些扩展名的源文件都必须使用 nvcc 编译，如使用 nvcc 编译中所述。 # Compilation with NVCC 内核 (kernels) 可以使用 CUDA 指令集架构编写，称为 PTX，在 PTX 参考手册中有描述。然而，使用高级编程语言 (如 c++) 通常更有效。在这两种情况下，内核都必须被 nvcc 编译成二进制代码才能在设备上执行。 nvcc 是一个编译器驱动程序，它简化了编译 c++ 或 PTX 代码的过程：它提供了简单而熟悉的命令行选项，并通过调用实现不同编译阶段的工具集合来执行它们。 用 nvcc 编译的源文件可以混合包含主机代码 (即在主机上执行的代码) 和设备代码 (即在设备上执行的代码)。Nvcc 的基本工作流程包括将设备代码从主机代码中分离出来，然后: 将设备代码编译为汇编形式 (PTX 代码) 和 / 或二进制形式 (立方体对象)， and modifying the host code by replacing the &lt;&lt;&lt;…&gt;&gt;&gt; syntax introduced in Kernels (and de\u0002scribed in more details in Execution Configuration) by the necessary CUDA runtime function calls to load and launch each compiled kernel from the PTX code and/or cubin object. 修改后的主机代码可以作为 c++ 代码输出，然后使用其他工具进行编译，也可以通过让 nvcc 在最后一个编译阶段调用主机编译器直接作为目标代码输出。 Applications can then: Either link to the compiled host code (this is the most common case), Or ignore the modified host code (if any) and use the CUDA driver API (see Driver API) to load and execute the PTX code or cubin object. # 即时编译 应用程序在运行时加载的任何 PTX 代码都被设备驱动程序进一步编译为二进制代码。这被称为即时编译。即时编译增加了应用程序加载时间，但允许应用程序从每个新设备驱动程序带来的任何新的编译器改进中受益。这也是应用程序在编译应用程序时不存在的设备上运行的唯一方法. 当设备驱动程序即时编译某些应用程序的 PTX 代码时，它会自动缓存生成的二进制代码的副本，以避免在后续应用程序调用中重复编译。缓存 (称为计算缓存) 在设备驱动程序升级时自动失效，因此应用程序可以从设备驱动程序中内置的新即时编译器的改进中受益。 # Binary Compatibility 二进制代码是特定于体系结构的。使用指定目标体系结构的编译器选项 - code 生成 cubin 对象: For example, compiling with -code=sm_80 produces binary code for devices of compute capability 8.0. Binary compatibility is guaranteed from one minor revision to the next one, but not from one minor revision to the previous one or across major revisions. In other words, a cubin object generated for compute capability X.y will only execute on devices of compute capability X.z where z.y. # PTX 兼容性 某些 PTX 指令仅在具有较高计算能力的设备上受支持。例如，Warp Shuffle 函数仅在计算能力 5.0 及以上的设备上支持。arch 编译器选项指定在将 c++ 编译为 PTX 代码时假定的计算能力。因此，例如，包含 warp shuffle 的代码必须使用 - arch=compute_30 (或更高) 来编译。 为某些特定计算能力而产生的 PTX 代码总是可以编译为具有更大或相同计算能力的二进制代码。请注意，从较早的 PTX 版本编译的二进制文件可能不使用某些硬件特性。例如，一个二进制目标设备的计算能力 7.0 (Volta) 编译自 PTX 生成的计算能力 6.0 (Pascal) 将不使用张量核心指令，因为这些在 Pascal 上是不可用的。因此，如果使用最新版本的 PTX 生成二进制文件，最终二进制文件的性能可能会更差。 # 应用程序兼容性 要在具有特定计算能力的设备上执行代码，应用程序必须加载与此计算能力兼容的二进制或 PTX 代码，如二进制兼容性和 PTX 兼容性中所述。特别是，为了能够在具有更高计算能力的未来架构上执行代码 (目前还不能生成二进制代码)，应用程序必须加载将为这些设备即时编译的 PTX 代码 # CUDA Runtime # Initialization 运行时没有显式的初始化函数；它在第一次调用运行时函数时初始化 (更具体地说，除了参考手册中的错误处理和版本管理部分中的函数之外的任何函数)。在计时运行时函数调用时，以及在解释从第一次调用到运行时的错误代码时，需要记住这一点。","categories":[],"tags":[]},{"title":"","slug":"如何在unity中手写一个四叉树地形lod系统（一）","date":"2023-06-11T06:24:01.131Z","updated":"2023-06-11T06:25:28.054Z","comments":true,"path":"2023/06/11/如何在unity中手写一个四叉树地形lod系统（一）/","link":"","permalink":"http://example.com/2023/06/11/%E5%A6%82%E4%BD%95%E5%9C%A8unity%E4%B8%AD%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9B%9B%E5%8F%89%E6%A0%91%E5%9C%B0%E5%BD%A2lod%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"在 unity 中，我们可以使用 unity 自带的地形系统创建一个超大的地形场景，并且可以利用地形图层，创建出富有真实感的地表材质。但是当我们需要更改地形的渲染方式的时候，比如需要风格化渲染时，使用 unity 自带的地形系统就会很麻烦。因此，我尝试在 unity 中使用 mesh 的方式实现了一个简易的地形系统，这样地形的渲染就和场景中其他网格物体的渲染没有什么区别了，可以很方便地实现各种效果。 以下我将分步简要描述实现思路与过程，目录如下： 将 world machine 中创建的地形导入到 unity 的 mesh 中； 处理地形数据，按照四叉树层级分块； 根据摄像机位置动态地组合分块，达到动态地形 LOD 的效果； 以下是实现的具体过程，个人编码水平比较低，希望大家多多提出意见。 一、导入地形数据 在 unity 自带的地形系统中，我们可以通过一张高度图的方式将地形数据从地形生成软件（World Machine，Gaea 等）导入到 unity 引擎中，这张高度图通常是原始图片数据格式 (.raw)。.raw 格式的图片保存了最原始、无损的信息，而我们常用的 png、jpg 图片采用了一些压缩算法来减小图片的大小，但是会损失一些数据，因此在程序化地形工作流中，我们常常使用.raw 来保存地形信息。 但是.raw 格式的图片并不方便，windows 本身是无法查看这类图片的，而 C# 也需要配置一些环境，并且也比较复杂。因此我选择不使用.raw 图片来存储地形数据，转而直接使用模型文件.obj 格式。 在 World Machine 中，我们可以直接导出.obj 文件格式，方式如下： 其中 Triangulation 项表示导出模型的精度，我们选择 Full Resolution Mesh，创建完整的模型。第三项坐标系统，我们选择 X=east Z=north，以匹配 unity 的坐标系统。其他导出选项可以根据需要来选择。 然后我们就获得了地形网格模型，是常见的 obj 文件，本质上是一个，分别用建模软件和 VS code 查看如下 可以看到三角形网格和以字符文本形式保存的模型信息。在.obj文件中，v关键字表示顶点，后面三个值分别表示该顶点的x、y、z位置坐标。 现在我们获得了地形的完整的模型文件，在使用它之前需要先将它按照四叉树分割成小块，具体如下图所示： 对于本例而言，地形大小为 4096*4096，因此采用六级 LOD，最终 LOD0 有 1024 块，所有 LOD 分块一共 1365 块，我们先从 obj 文件中提取顶点数据，再根据每一块的 LOD 级别与覆盖范围分别建立网格。 因此，我们先用 C++ 写一个小程序来将顶点信息提取出来，存入到一个文本文件中，方便后续建立网格时使用。 观察顶点数据，发现顶点数据按照行 - 列的方式排列，这方便了后续的操作。因此，为了提高文件读取的效率，可以将 x 轴与 z 轴的数据抛弃，通过在第一行添加一个常数来表示 x、z 平面上顶点的间隔距离，并且添加第二个常数来表示地形高度的乘数，增强了我们对网格的控制。 在完善之后，这一部分的 C++ 代码如下： #include #include #include #include #include using namespace std; struct vec3{ int x; float y; int z; }; vec3 vertices[16785409]; int main() { fstream newtxt; newtxt.open(R&quot;(D:\\WorldMachine\\World Machine 4016\\World Machine 4016 Professional\\World Machine Documents\\Desert\\TerrainData.txt)&quot;, ios::out); fstream myObj; myObj.open(R&quot;(D:\\WorldMachine\\World Machine 4016\\World Machine 4016 Professional\\World Machine Documents\\Desert\\height.obj)&quot;, ios::in); if(!myObj.is_open()) std::cerr&lt;&lt;&quot;cannot open the file&quot;; // 输出先导数据 float xz_bias = 5; float y_bias = 1; newtxt &lt;&lt; xz_bias &lt;&lt; &quot; &quot; &lt;&lt; y_bias &lt;&lt; endl; // 全局 char buffer[1024] = {0};// 读取文件行缓存 int mesh_num = 0; // 网格（物体）计数编号 int count_num = 0; // 行数计数编号 int cnt_vert = 0; while (myObj.getline(buffer,sizeof(buffer))){ count_num ++; stringstream ss(buffer); // 一行的字符串流操作 if (ss.str().empty()) // 空行 continue; string flag; // 行首关键字 ss &gt;&gt; flag; if (flag == &quot;#&quot;){ cout &lt;&lt; &quot;第 &quot; &lt;&lt; count_num &lt;&lt; &quot; 行: &quot; &lt;&lt; &quot;这是一行注释, &quot; &lt;&lt; &quot;注释的内容是:&quot; &lt;&lt; ss.str() &lt;&lt; endl; } else if (flag == &quot;mtllib&quot;){ continue; } else if (flag == &quot;v&quot;){ // 顶点 float a, b, c; ss &gt;&gt; a &gt;&gt; b &gt;&gt; c; vertices[cnt_vert].x = (cnt_vert % 4097); vertices[cnt_vert].y = b; vertices[cnt_vert].z = (cnt_vert / 4097); newtxt &lt;&lt; b &lt;&lt; endl; cnt_vert ++; } else cout &lt;&lt; ss.str() &lt;&lt; endl; memset(buffer, 0, sizeof(buffer)); } myObj.close(); cout &lt;&lt; &quot;读取文件完成力&quot; &lt;&lt; endl; return 0; } 在拿到处理后的顶点数据后，我们打开 unity，新建一个脚本。 首先创建如下的成员变量： // 需要读取的文件路径 public string datapath; private float xzbias = 0, ybias = 0; // 格点间隔距离与高度乘数 public int Size = 4097; // 地形的规模（正方形边长，要求是2的幂+1） private int LEN; // 常数，表示完整顶点组的长度，等于Size^2 private int len; // 常数，表示单片顶点组的长度，等于129*129 private Vector3[] CompVert; // 完整的地形顶点数据，在开始时从文本文件读取数据到该顶点组，在构建mesh时按需从该顶点组读取数据 private Vector2[] CompUV1; // CompVert对应的第一套UV（地表贴图纹理uv） private Vector2[] CompUV2; // CompVert对应的第二套UV（遮罩图贴图splat map uv） private Mesh LodMesh; // 结果的网格，在每次四叉树遍历过程中即时更新该mesh并保存至本地，因此不需要开数组 private Vector3[] vert; // 结果的顶点数据 private Vector2[] uv1; private Vector2[] uv2; private int[] tri; // 结果的三角形数据（不需要在每次遍历中更新） private struct quadTreeNodeInfo // 地形瓦片 四叉树节点 信息 { public Vector2 begin_Pos; // 开始顶点在完整顶点组中的第几行、第几列 public int interval; // 该地形瓦片的连续顶点在完整顶点组中对应顶点相差数量（LOD0对应该值为1，LOD2对应该值为4） public int LodLeval; // 该地形瓦片的lod等级 public Vector2 Center; // 该地形瓦片的xz平面几何中心位置 } private quadTreeNodeInfo[] qTree; // 四叉树 我们为所有顶点创建了两套uv，因为地表纹理贴图的uv和splat map的uv是不同的。 然后将文本文件中的地形高度信息读取到 CompVert 数组中。我们用 C# 中的 StreamReader 类来按行读取，再利用 string.Split () 方法将读取到的行根据空格分割，然后用 float.TryParse () 来将字符串转化为浮点数。同时，按照行 - 列的顺序填充 x、z 轴的顶点位置和两套 uv 的信息。这一部分的代码如下： private void ReadRawData() // 参数1：文本文件路径；参数2：完整顶点组数组引用 { // 创建一个StreamReader类 StreamReader RawTerrainData = new StreamReader(@datapath); string line; line = RawTerrainData.ReadLine(); string[] bias = line.Split(' '); float.TryParse(bias[0], out xzbias); float.TryParse(bias[1], out ybias); for (int i = 0; i &lt; LEN; i++) // 读取所有顶点 并且给原始uv数据赋值 { line = RawTerrainData.ReadLine(); string[] stringdata = line.Split(' '); float y = 0; float.TryParse(stringdata[0], out y); // xz等于计算值*偏移值，y等于读取值*偏移值 CompVert[i].x = (i % 4097) * xzbias; CompVert[i].z = ((int)(i / 4097)) * xzbias; CompVert[i].y = y * ybias; // uv1在0-1之间周期性变化 CompUV1[i].x = ((i % 4097) % 2) * 0.5f; CompUV1[i].y = (((int)(i / 4097)) % 2) * 0.5f; // uv2在0-1之间随着0-4097之间变化 CompUV2[i].x = (float)(i % 4097) / 4097.0f; CompUV2[i].y = ((float)i / 4097.0f) / 4097.0f; } } 在完整填充了的顶点数组后，我们还要准备好四叉树。四叉树用线性数组存储，索引 0 表示根节点，对于索引为 i（i≠0）的元素，其父节点为 (i-1)/4 取整，其子节点（如果存在）为 i4+1 到 i4+4。 四叉树的每个子节点存放了以下信息： 1、 开始位置：该节点代表的地形分块的第一个顶点在完整顶点组中的索引是第几行、第几列； 2、 间隔距离：该节点代表的地形分块的相邻的顶点在完整顶点组中的索引的间隔索引数； 3、 LOD 等级：该节点代表的地形分块的 LOD 等级，0 表示最细节，最大值表示最简单； 4、 中心位置：该节点代表的地形分块的顶点的在世界空间中的几何中心坐标； 其中，开始位置与间隔距离信息在创建网格时使用，中心位置信息在动态显示地形时使用。 然后我们将四叉树的信息保存到本地，因为这部分的数据不会在游戏运行时被更改。我们按照行数对应四叉树节点索引的方式，数据间以空格分隔的方式保存到本地，这一部分的代码如下所示： private void BuildQuadTree() { // 循环形式 // 处理根节点 qTree[0].Center.x = CompVert[Size * (Size - 1) / 2 + (Size - 1) / 2].x; qTree[0].Center.y = CompVert[Size * (Size - 1) / 2 + (Size - 1) / 2].z; qTree[0].begin_Pos = new Vector2(0, 0); qTree[0].interval = (Size - 1) / 128; qTree[0].LodLeval = 5; // 完整顶点是0级，最简是6级 for(int index = 1; index &lt; qTree.Length; index++) { int num = (index - 1) % 4; int parent = (int)((index - 1) / 4); qTree[index].LodLeval = qTree[parent].LodLeval - 1; qTree[index].interval = qTree[parent].interval / 2; qTree[index].Center = qTree[parent].Center; if (num == 0) { qTree[index].begin_Pos = qTree[parent].begin_Pos; qTree[index].Center.x -= 64 * qTree[index].interval * xzbias; qTree[index].Center.y -= 64 * qTree[index].interval * xzbias; } else if (num == 1) { qTree[index].begin_Pos = new Vector2(qTree[parent].begin_Pos.x + 64 * qTree[parent].interval, qTree[parent].begin_Pos.y); qTree[index].Center.x += 64 * qTree[index].interval * xzbias; qTree[index].Center.y -= 64 * qTree[index].interval * xzbias; } else if (num == 2) { qTree[index].begin_Pos = new Vector2(qTree[parent].begin_Pos.x, qTree[parent].begin_Pos.y + 64 * qTree[parent].interval); qTree[index].Center.x -= 64 * qTree[index].interval * xzbias; qTree[index].Center.y += 64 * qTree[index].interval * xzbias; } else { qTree[index].begin_Pos = new Vector2(qTree[parent].begin_Pos.x + 64 * qTree[parent].interval, qTree[parent].begin_Pos.y + 64 * qTree[parent].interval); qTree[index].Center.x += 64 * qTree[index].interval * xzbias; qTree[index].Center.y += 64 * qTree[index].interval * xzbias; } } } private void SaveTree() { using (StreamWriter sw = new StreamWriter(@&quot;E:\\Unity\\MyProjects\\Desert_01\\Assets\\TerrainTree\\MyQTree.txt&quot;)) { for (int i = 0; i &lt; qTree.Length; i++) { string line; line = qTree[i].begin_Pos.x.ToString(); line += &quot; &quot;; line += qTree[i].begin_Pos.y.ToString(); line += &quot; &quot;; line += qTree[i].interval.ToString(); line += &quot; &quot;; line += qTree[i].LodLeval.ToString(); line += &quot; &quot;; line += qTree[i].Center.x.ToString(); line += &quot; &quot;; line += qTree[i].Center.y.ToString(); sw.WriteLine(line); } } } 四叉树创建完成后，我们在创建并保存网格之前，先创建三角形索引数组。在一般情况下，我们在创建网格时会先创建顶点数组再创建三角形索引数组，但是在这里我们每个地形分块的顶点排列和三角形索引情况完全一致，唯一的区别是顶点位置的区别，因此我们先创建出三角形数组再在遍历四叉树时每次创建网格时在改变顶点数据就可以了。 在这里，我暂时没有考虑不同LOD层级的地形块的接缝问题，因此三角形按照两个三角形-一个四边形为一个单位，按照行-列的顺序来创建。这一部分的代码如下： private void CreateTriangle() { int tri_n = 0; for (int u = 0; u &lt; 128; u++) { for (int v = 0; v &lt; 128; v++) { tri[tri_n * 6] = u * 129 + v; tri[tri_n * 6 + 1] = tri[tri_n * 6 + 4] = (u + 1) * 129 + v; tri[tri_n * 6 + 2] = tri[tri_n * 6 + 3] = u * 129 + v + 1; tri[tri_n * 6 + 5] = (u + 1) * 129 + v + 1; tri_n++; } } } 接下来就是重头戏——创建网格了。我们根据四叉树的每一个节点创建一个网格。第一步我们首先将网格的索引数类型改为unsigned int32，unity默认的索引是16位整型，这样会导致顶点数量非常容易溢出，因此更改为32位。然后我们根据四叉树信息获取地形块的开始位置，按照间隔距离递增的方式进行行-列遍历，查找完整顶点数组数据，创建出该块网格顶点数组。同时创建uv数据。在顶点、uv、三角形都完成后，重新计算一次顶点法线。然后将网格保存到Assets目录。这一部分的代码如下： private void CreateMesh() { for(int i = 0; i &lt; qTree.Length; i++) { Mesh mesh = new Mesh(); mesh.indexFormat = LodMesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32; int begin; if (i == 0) begin = 0; else begin = (int)(qTree[i].begin_Pos.x * Size + qTree[i].begin_Pos.y); for (int u = 0; u &lt; 129; u++) { for (int v = 0; v &lt; 129; v++) { vert[u * 129 + v] = CompVert[begin + u * Size * qTree[i].interval + v * qTree[i].interval]; uv1[u * 129 + v] = CompUV1[begin + u * Size * qTree[i].interval + v * qTree[i].interval]; //uv2[u * 129 + v] = CompUV2[begin + u * Size * qTree[i].interval + v * qTree[i].interval]; } } mesh.vertices = vert; mesh.uv = uv1; mesh.uv2 = uv2; mesh.triangles = tri; mesh.RecalculateNormals(); string MeshName = &quot;Assets/LodMeshes/LodMesh_&quot; + i.ToString() + &quot;.asset&quot;; AssetDatabase.CreateAsset(mesh, MeshName); } } 至此，我们已经完成了四叉树地形的大部分工作，在下一节，我将简要讲解如何在游戏过程中动态地组合创建好的地形分块网格，从而实现地形实时LOD的效果。","categories":[],"tags":[]},{"title":"","slug":"unity四叉树地形系统（二）","date":"2023-05-30T08:01:31.274Z","updated":"2023-06-10T15:34:19.523Z","comments":true,"path":"2023/05/30/unity四叉树地形系统（二）/","link":"","permalink":"http://example.com/2023/05/30/unity%E5%9B%9B%E5%8F%89%E6%A0%91%E5%9C%B0%E5%BD%A2%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"在根据四叉树节点创建了 1365 个地形分块网格并保存到本地后，我们接下来要在游戏运行的过程中动态地显示所需的网格，这是最关键的一步。 如何根据摄像机位置动态地选择地形块？这其中体现了由整体到局部，从简单到复杂的原则。 我们首先创建三个缓存列表。 我们先将索引为 0 的地形分块（即最高 LOD 等级）的分块放入 BufferA； 然后遍历 BufferA，判断 BufferA 中的每一个元素是否符合 “无需更加详细” 的条件，如果是，将它放入 BufferFinal，否则放入 BufferB； 在遍历完 BufferA 中的元素后，清空 BufferA，将 BufferB 的元素全部复制到 BufferA 中，清空 BufferB； 重复 2-3 步骤的操作，直到 BufferA、BufferB 列表均空。 此时 BufferFinal 中存储的索引即是我们最终所需要的地形网格分块的索引。 我们把以上的操作封装成函数，在游戏开始运行时调用一次。这一部分的代码如下： &lt;代码&gt; 这一部分我选择将需要的网格实例化到子对象中而没有合并，如果需要优化的话，应该将网格合并成一个，可以减少 DrawCall 的数量。 同时要注意的是：网格的实例化与显示并非在每一帧进行，可以维护一个数对来表示玩家摄像机所在的区域，如果玩家摄像机离开了原本的区域进入到新的区域中，那我们便执行一此地形网格更新操作： &lt;代码&gt; 补充一点，在此之前我们可以从本地读取，在上一节生成网格时保存的四叉树信息，这部分代码很简单，如下所示： &lt;代码&gt; 至此，我们大致完成了一个非常基础的一个四叉树网格地形系统，这其中还有很多问题，我大致思考了一下改进的方向： 性能优化方面的问题问题，比如显示的网格应该合并成一个而非保持多个对象；明显超出视线范围的地形网格分块应该直接剔除掉而非继续显示等； 代码复用性的方面的问题，有许多数据直接写死在代码里面，导致耦合度过高。在改进的时候，应该将这些数据参数化，将算法更优化，来降低耦合度，增强代码对不同大小的地形的复用能力； 效果实现方面的问题，没有考虑不同 LOD 等级的地块的连接处的露缝问题，应该在后续中改进 这里我仅仅实现了最基本的网格动态显示，没有考虑渲染，在以后的改进中，我会尝试在地形渲染方面做出更多改进。","categories":[],"tags":[]},{"title":"","slug":"hello-world","date":"2023-05-27T08:45:40.095Z","updated":"2023-06-10T15:21:18.463Z","comments":true,"path":"2023/05/27/hello-world/","link":"","permalink":"http://example.com/2023/05/27/hello-world/","excerpt":"","text":"# 为什么我喜欢玩原神 原神好玩捏","categories":[],"tags":[]}],"categories":[],"tags":[]}